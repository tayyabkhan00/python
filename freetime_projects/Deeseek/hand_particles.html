<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled 3D Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #webcamContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 2;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
            border: 2px solid #4fc3f7;
        }
        
        #webcam {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror the webcam */
            background: #000;
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        
        #info h2 {
            margin-bottom: 10px;
            color: #4fc3f7;
        }
        
        #status {
            color: #ff9800;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #4fc3f7;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .value-display {
            display: inline-block;
            width: 40px;
            text-align: right;
        }
        
        button {
            background: #4fc3f7;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #29b6f6;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #particleCount {
            font-weight: bold;
            color: #4fc3f7;
        }
        
        .hand-info {
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .hand-info span {
            color: #4fc3f7;
        }
        
        .gesture-info {
            position: absolute;
            top: 270px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            width: 320px;
        }
        
        .gesture-info h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .gesture-list {
            list-style: none;
        }
        
        .gesture-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }
        
        .gesture-list li:before {
            content: "üëâ";
            position: absolute;
            left: 0;
        }
        
        .hand-visualizer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px;
        }
        
        .hand-visualizer h3 {
            color: #4fc3f7;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }
        
        #handCanvas {
            width: 100%;
            height: calc(100% - 30px);
            background: rgba(20, 20, 30, 0.8);
            border-radius: 5px;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Loading hand detection model...</p>
        <p id="loadingStatus">Initializing...</p>
    </div>
    
    <div id="container">
        <div id="info">
            <h2>Hand-Controlled Particle System</h2>
            <p>Show your hand to the webcam</p>
            <p>Particles: <span id="particleCount">5000</span></p>
            <p id="status">Detecting hand...</p>
            <div class="hand-info">
                Hand Confidence: <span id="handConfidence">0</span><br>
                Gesture: <span id="gesture">None</span>
            </div>
        </div>
        
        <div class="gesture-info">
            <h3>Hand Gestures:</h3>
            <ul class="gesture-list">
                <li><strong>Open Hand:</strong> Attract particles</li>
                <li><strong>Closed Fist:</strong> Repel particles</li>
                <li><strong>Peace Sign ‚úåÔ∏è:</strong> Create vortex</li>
                <li><strong>Thumbs Up üëç:</strong> Change colors</li>
                <li><strong>Move Hand:</strong> Control particle flow</li>
            </ul>
        </div>
        
        <div class="hand-visualizer">
            <h3>Hand Position</h3>
            <canvas id="handCanvas"></canvas>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Particle Count: <span class="value-display" id="countValue">5000</span></label>
                <input type="range" id="particleCountSlider" min="100" max="10000" value="5000" step="100">
            </div>
            
            <div class="control-group">
                <label>Particle Size: <span class="value-display" id="sizeValue">2.0</span></label>
                <input type="range" id="sizeSlider" min="0.1" max="5" value="2" step="0.1">
            </div>
            
            <div class="control-group">
                <label>Hand Force: <span class="value-display" id="forceValue">0.5</span></label>
                <input type="range" id="forceSlider" min="0.1" max="2" value="0.5" step="0.1">
            </div>
            
            <div class="control-group">
                <label>Interaction Range: <span class="value-display" id="rangeValue">15</span></label>
                <input type="range" id="rangeSlider" min="5" max="30" value="15" step="1">
            </div>
            
            <div class="control-group">
                <button id="resetBtn">Reset Particles</button>
                <button id="toggleHandBtn" disabled>Start Hand Tracking</button>
            </div>
        </div>
        
        <div id="webcamContainer">
            <video id="webcam" autoplay playsinline muted></video>
            <canvas id="overlayCanvas"></canvas>
        </div>
    </div>

    <script>
        // Initialize variables
        let scene, camera, renderer;
        let particleSystem, particles, particleGeometry, particleMaterial;
        let particleCount = 5000;
        
        // Particle properties
        let particlePositions = [];
        let particleVelocities = [];
        let particleColors = [];
        let originalPositions = [];
        
        // Hand tracking variables
        let handDetector = null;
        let handPredictions = [];
        let isHandTracking = false;
        let lastHandPosition = { x: 0, y: 0, z: 0 };
        let currentGesture = "None";
        
        // Configuration
        let config = {
            size: 2.0,
            handForce: 0.5,
            interactionRange: 15,
            attractMode: true,
            vortexMode: false,
            colorChangeMode: false
        };
        
        // Initialize Three.js
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.id = 'threeCanvas';
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // Create particles
            createParticles();
            
            // Setup event listeners for controls
            setupControls();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function createParticles() {
            // Remove existing particle system if it exists
            if (particleSystem) {
                scene.remove(particleSystem);
                if (particleGeometry) particleGeometry.dispose();
                if (particleMaterial) particleMaterial.dispose();
            }
            
            // Create particle geometry
            particleGeometry = new THREE.BufferGeometry();
            particles = new Float32Array(particleCount * 3);
            particleColors = new Float32Array(particleCount * 3);
            particlePositions = [];
            particleVelocities = [];
            originalPositions = [];
            
            // Create colors for particles
            const color = new THREE.Color();
            
            // Initialize particles
            for (let i = 0; i < particleCount; i++) {
                // Random position within a sphere
                const radius = 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                particles[i * 3] = x;
                particles[i * 3 + 1] = y;
                particles[i * 3 + 2] = z;
                
                // Store original position for reset
                originalPositions.push(new THREE.Vector3(x, y, z));
                
                // Zero initial velocity
                particleVelocities.push(new THREE.Vector3(0, 0, 0));
                
                // Store position for calculations
                particlePositions.push(new THREE.Vector3(x, y, z));
                
                // Random blueish color
                const hue = 0.6 + Math.random() * 0.2;
                color.setHSL(hue, 0.8, 0.6);
                
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
            }
            
            // Set geometry attributes
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particles, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            // Create particle material
            particleMaterial = new THREE.PointsMaterial({
                size: config.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            // Create particle system
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }
        
        // Hand detection setup
        async function setupHandDetection() {
            try {
                updateLoadingStatus("Loading TensorFlow.js...");
                
                // Check if TensorFlow.js is available
                if (!tf || !window.handPoseDetection) {
                    throw new Error("Required libraries not loaded");
                }
                
                // Create detector
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'tfjs',
                    modelType: 'full',
                    maxHands: 1
                };
                
                updateLoadingStatus("Loading hand detection model...");
                handDetector = await handPoseDetection.createDetector(model, detectorConfig);
                
                updateLoadingStatus("Starting webcam...");
                await startWebcam();
                
                // Enable hand tracking button
                document.getElementById('toggleHandBtn').disabled = false;
                document.getElementById('toggleHandBtn').textContent = "Start Hand Tracking";
                
                updateLoadingStatus("Ready!");
                
                // Hide loading screen after a delay
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
                
            } catch (error) {
                console.error("Error setting up hand detection:", error);
                updateLoadingStatus(`Error: ${error.message}`);
                document.getElementById('toggleHandBtn').disabled = true;
                document.getElementById('toggleHandBtn').textContent = "Hand Tracking Failed";
            }
        }
        
        async function startWebcam() {
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: 'user'
                }
            });
            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }
        
        async function detectHand() {
            if (!handDetector || !isHandTracking) return;
            
            const video = document.getElementById('webcam');
            const overlay = document.getElementById('overlayCanvas');
            const overlayCtx = overlay.getContext('2d');
            
            // Set overlay dimensions
            overlay.width = video.videoWidth;
            overlay.height = video.videoHeight;
            
            try {
                // Detect hands
                handPredictions = await handDetector.estimateHands(video, {
                    flipHorizontal: true
                });
                
                // Clear overlay
                overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
                
                if (handPredictions.length > 0) {
                    const hand = handPredictions[0];
                    const keypoints = hand.keypoints;
                    
                    // Draw hand landmarks
                    drawHandLandmarks(overlayCtx, keypoints);
                    
                    // Calculate hand position in 3D space
                    const handPos = calculateHandPosition(keypoints);
                    lastHandPosition = handPos;
                    
                    // Detect gesture
                    currentGesture = detectGesture(keypoints);
                    document.getElementById('gesture').textContent = currentGesture;
                    
                    // Update hand confidence
                    const confidence = hand.keypoints3D ? 
                        hand.keypoints3D[0].score.toFixed(2) : '0.95';
                    document.getElementById('handConfidence').textContent = confidence;
                    
                    // Update status
                    document.getElementById('status').textContent = "Hand detected!";
                    document.getElementById('status').style.color = "#4caf50";
                    
                    // Update hand visualizer
                    updateHandVisualizer(keypoints);
                    
                    // Apply gesture effects
                    applyGestureEffects(currentGesture);
                    
                } else {
                    document.getElementById('status').textContent = "Show hand to webcam";
                    document.getElementById('status').style.color = "#ff9800";
                    document.getElementById('handConfidence').textContent = "0";
                    document.getElementById('gesture').textContent = "None";
                }
                
            } catch (error) {
                console.error("Error detecting hand:", error);
            }
            
            // Continue detection
            requestAnimationFrame(detectHand);
        }
        
        function drawHandLandmarks(ctx, keypoints) {
            // Draw connections
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8], // Index finger
                [0, 9], [9, 10], [10, 11], [11, 12], // Middle finger
                [0, 13], [13, 14], [14, 15], [15, 16], // Ring finger
                [0, 17], [17, 18], [18, 19], [19, 20] // Pinky
            ];
            
            // Draw connections
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            
            connections.forEach(connection => {
                const [start, end] = connection;
                const startPoint = keypoints[start];
                const endPoint = keypoints[end];
                
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(endPoint.x, endPoint.y);
                ctx.stroke();
            });
            
            // Draw keypoints
            keypoints.forEach(point => {
                ctx.fillStyle = '#ff9800';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function calculateHandPosition(keypoints) {
            // Use wrist position as reference
            const wrist = keypoints[0];
            
            // Calculate average finger position for depth estimation
            let avgX = 0, avgY = 0;
            keypoints.forEach(point => {
                avgX += point.x;
                avgY += point.y;
            });
            avgX /= keypoints.length;
            avgY /= keypoints.length;
            
            // Map to 3D space
            // Normalize coordinates (0-1) then map to 3D space
            const video = document.getElementById('webcam');
            const x = ((wrist.x / video.videoWidth) - 0.5) * 40; // -20 to 20
            const y = ((0.5 - wrist.y / video.videoHeight)) * 40; // -20 to 20
            
            // Estimate Z based on hand size
            const bbox = getHandBoundingBox(keypoints);
            const handSize = Math.max(bbox.width, bbox.height);
            const maxHandSize = Math.min(video.videoWidth, video.videoHeight) * 0.5;
            const z = (handSize / maxHandSize) * 20 + 5; // 5 to 25
            
            return { x, y, z };
        }
        
        function getHandBoundingBox(keypoints) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            keypoints.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        function detectGesture(keypoints) {
            // Simple gesture detection based on finger positions
            const tips = [4, 8, 12, 16, 20]; // Thumb, index, middle, ring, pinky tips
            const mcp = [2, 5, 9, 13, 17]; // Finger bases
            
            let extendedFingers = 0;
            let isFist = true;
            
            // Check each finger
            for (let i = 0; i < tips.length; i++) {
                const tip = keypoints[tips[i]];
                const base = keypoints[mcp[i]];
                
                // For thumb, use different calculation
                if (i === 0) {
                    // Check if thumb is extended (x-coordinate difference)
                    const thumbExtended = tip.x < base.x;
                    if (thumbExtended) {
                        extendedFingers++;
                        isFist = false;
                    }
                } else {
                    // For other fingers, check if tip is above base (y-coordinate)
                    const fingerExtended = tip.y < base.y;
                    if (fingerExtended) {
                        extendedFingers++;
                        isFist = false;
                    }
                }
            }
            
            // Determine gesture
            if (extendedFingers === 5) return "Open Hand";
            if (extendedFingers === 2 && 
                keypoints[8].y < keypoints[5].y && 
                keypoints[12].y < keypoints[9].y) return "Peace Sign";
            if (extendedFingers === 1 && 
                keypoints[4].x < keypoints[2].x) return "Thumbs Up";
            if (isFist) return "Closed Fist";
            
            return "Moving";
        }
        
        function applyGestureEffects(gesture) {
            switch(gesture) {
                case "Open Hand":
                    config.attractMode = true;
                    config.vortexMode = false;
                    break;
                case "Closed Fist":
                    config.attractMode = false;
                    config.vortexMode = false;
                    break;
                case "Peace Sign":
                    config.vortexMode = true;
                    break;
                case "Thumbs Up":
                    config.colorChangeMode = true;
                    break;
                default:
                    config.vortexMode = false;
                    config.colorChangeMode = false;
            }
        }
        
        function updateHandVisualizer(keypoints) {
            const canvas = document.getElementById('handCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw simplified hand representation
            ctx.fillStyle = 'rgba(79, 195, 247, 0.3)';
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            
            // Draw palm circle at wrist position
            const wrist = keypoints[0];
            const scale = canvas.width / 640; // Scale from webcam resolution
            
            // Map keypoints to canvas
            const mappedPoints = keypoints.map(point => ({
                x: point.x * scale,
                y: point.y * scale
            }));
            
            // Draw connections
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8], // Index
                [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                [0, 17], [17, 18], [18, 19], [19, 20] // Pinky
            ];
            
            // Adjust points to fit canvas
            const offsetX = (canvas.width - mappedPoints[0].x) / 2;
            const offsetY = (canvas.height - mappedPoints[0].y) / 2;
            
            connections.forEach(([start, end]) => {
                const p1 = mappedPoints[start];
                const p2 = mappedPoints[end];
                
                ctx.beginPath();
                ctx.moveTo(p1.x + offsetX, p1.y + offsetY);
                ctx.lineTo(p2.x + offsetX, p2.y + offsetY);
                ctx.stroke();
            });
            
            // Draw points
            mappedPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x + offsetX, point.y + offsetY, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function updateParticles() {
            if (!particleGeometry) return;
            
            const positions = particleGeometry.attributes.position.array;
            const colors = particleGeometry.attributes.color.array;
            const time = Date.now() * 0.001;
            
            // Apply hand interaction if hand is detected
            if (handPredictions.length > 0 && isHandTracking) {
                const handPos = new THREE.Vector3(
                    lastHandPosition.x,
                    lastHandPosition.y,
                    lastHandPosition.z
                );
                
                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    const position = particlePositions[i];
                    const velocity = particleVelocities[i];
                    
                    // Calculate distance to hand
                    const distance = position.distanceTo(handPos);
                    
                    if (distance < config.interactionRange) {
                        // Calculate direction from particle to hand
                        const direction = new THREE.Vector3().subVectors(handPos, position).normalize();
                        
                        if (config.vortexMode) {
                            // Vortex effect - circular motion around hand
                            const vortexForce = new THREE.Vector3(
                                -direction.y,
                                direction.x,
                                Math.sin(time) * 0.5
                            ).normalize();
                            vortexForce.multiplyScalar(config.handForce * 0.5);
                            velocity.add(vortexForce);
                        } else if (config.attractMode) {
                            // Attract particles to hand
                            direction.multiplyScalar(config.handForce * 0.1);
                            velocity.add(direction);
                        } else {
                            // Repel particles from hand
                            direction.multiplyScalar(-config.handForce * 0.1);
                            velocity.add(direction);
                        }
                        
                        // Color change effect
                        if (config.colorChangeMode) {
                            const hue = (time * 0.5 + distance * 0.1) % 1;
                            const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                            colors[idx] = color.r;
                            colors[idx + 1] = color.g;
                            colors[idx + 2] = color.b;
                        }
                    }
                    
                    // Apply velocity damping
                    velocity.multiplyScalar(0.95);
                    
                    // Update position
                    position.add(velocity);
                    
                    // Apply boundary conditions
                    const boundary = 25;
                    if (position.length() > boundary) {
                        velocity.multiplyScalar(-0.5);
                    }
                    
                    // Apply gentle floating motion
                    position.x += Math.sin(time + i) * 0.01;
                    position.y += Math.cos(time * 1.3 + i) * 0.01;
                    position.z += Math.sin(time * 0.7 + i) * 0.01;
                    
                    // Update positions array
                    positions[idx] = position.x;
                    positions[idx + 1] = position.y;
                    positions[idx + 2] = position.z;
                }
                
                particleGeometry.attributes.color.needsUpdate = true;
            } else {
                // Default floating motion when no hand is detected
                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    const position = particlePositions[i];
                    
                    // Gentle floating animation
                    positions[idx] = position.x + Math.sin(time + i * 0.01) * 0.1;
                    positions[idx + 1] = position.y + Math.cos(time * 1.3 + i * 0.01) * 0.1;
                    positions[idx + 2] = position.z + Math.sin(time * 0.7 + i * 0.01) * 0.1;
                    
                    // Update stored position
                    position.set(positions[idx], positions[idx + 1], positions[idx + 2]);
                }
            }
            
            particleGeometry.attributes.position.needsUpdate = true;
        }
        
        function setupControls() {
            // Particle count slider
            document.getElementById('particleCountSlider').addEventListener('input', function(e) {
                particleCount = parseInt(e.target.value);
                document.getElementById('countValue').textContent = particleCount;
                document.getElementById('particleCount').textContent = particleCount;
                createParticles();
            });
            
            // Size slider
            document.getElementById('sizeSlider').addEventListener('input', function(e) {
                config.size = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = config.size.toFixed(1);
                if (particleSystem) {
                    particleSystem.material.size = config.size;
                }
            });
            
            // Force slider
            document.getElementById('forceSlider').addEventListener('input', function(e) {
                config.handForce = parseFloat(e.target.value);
                document.getElementById('forceValue').textContent = config.handForce.toFixed(1);
            });
            
            // Range slider
            document.getElementById('rangeSlider').addEventListener('input', function(e) {
                config.interactionRange = parseFloat(e.target.value);
                document.getElementById('rangeValue').textContent = config.interactionRange;
            });
            
            // Reset button
            document.getElementById('resetBtn').addEventListener('click', function() {
                createParticles();
            });
            
            // Toggle hand tracking button
            document.getElementById('toggleHandBtn').addEventListener('click', function() {
                isHandTracking = !isHandTracking;
                this.textContent = isHandTracking ? "Stop Hand Tracking" : "Start Hand Tracking";
                
                if (isHandTracking) {
                    detectHand();
                }
            });
        }
        
        function updateLoadingStatus(message) {
            document.getElementById('loadingStatus').textContent = message;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updateParticles();
            
            // Rotate camera slowly
            camera.position.x = Math.sin(Date.now() * 0.0005) * 30;
            camera.position.z = Math.cos(Date.now() * 0.0005) * 30;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        async function init() {
            initThreeJS();
            await setupHandDetection();
            animate();
        }
        
        // Start the application
        init();
    </script>
</body>
</html>